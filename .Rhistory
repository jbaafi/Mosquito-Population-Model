#setwd('~/Desktop/Code')
load("ParamsFuncs.RData")
# This is the value of iota for the manuscript
iota<-2.076622e-09
# This example is for the farm BCB
load('farm24.Rdata')
# This is the function that performs the numerical integration
sealice=function(t0,tfin,A0,C0,I0,P0){
# Functions for temperature and salinity
Temp = function(t){
Temp = a + b1*sin(2 * pi * t/365) + b2*cos(2 * pi * t/365)
return(Temp)
}
S = function(t){
S = c + d1*sin(2 * pi * t/365) + d2*cos(2 * pi * t/365)
return(S)
}
## Function to calculate the gradient
lice = function(t, y){
# The number of adult females
A = y[1]
# The number of plaktonic larvae
P = y[2]
# The time delay for the planktonic stage
tp = y[3]
# The number of infectious copepodids
I = y[4]
# The number of chalimus
C = y[5]
# The time delay for the chalimus stage
tc = y[6]
# Mortality durign the planktonic stage
PhiP = y[7]
# Mortality during the chalimus stage
PhiC = y[8]
# Apply timelags only once enough history has been established:
if (t - tp < t0) {
# The value of the lagged variables. Setting them equal to 0 means no lag.
lagp = yinit
} else{
# if the logical test passses we can calculate the lags
lagp = pastvalue(t - tp)
}
if (t - tc < t0) {
# The value of the lagged variables. Setting them equal to 0 means no lag.
lagc = yinit
} else{
# if the logical test passses we can calculate the lags
lagc = pastvalue(t - tc)
}
# The system of DDEs
P1 =  eta(Temp(t))*epsilon(Temp(t))*A*V(Temp(t),S(t))-eta(Temp(t-tp))*epsilon(Temp(t-tp))*lagp[1]*(gammaP(Temp(t))/gammaP(Temp(t-tp)))*V(Temp(t-tp),S(t-tp))*PhiP-mup(S(t))*P
I1 =  eta(Temp(t-tp))*epsilon(Temp(t-tp))*lagp[1]*(gammaP(Temp(t))/gammaP(Temp(t-tp)))*V(Temp(t-tp),S(t-tp))*PhiP-iota*f*I-mui(S(t))*I
C1 = iota*f*I-iota*f*lagc[4]*(gammaC(Temp(t))/gammaC(Temp(t-tc)))*PhiC-muc(S(t))*C
A1 = ((iota*f*lagc[4]*(gammaC(Temp(t))/gammaC(Temp(t-tc)))*PhiC)/2)-mua(S(t))*A
tp1 = 1 - gammaP(Temp(t))/gammaP(Temp(t-tp))
tc1 = 1 - gammaC(Temp(t))/gammaC(Temp(t-tc))
PhiP1 = PhiP*(gammaP(Temp(t))*mup(S(t-tp))/gammaP(Temp(t-tp))-mup(S(t)))
PhiC1 = PhiC*(gammaC(Temp(t))*muc(S(t-tc))/gammaC(Temp(t-tc))-muc(S(t)))
return(c(A1, P1, tp1, I1, C1, tc1, PhiP1, PhiC1))
}
# List of all paremeter Values
parameters = c(eta, epsilon, iota, V, mup, mui, muc, mua, t0, tfin, mup, f)
# Initial values calculated from their integral definitions: see the manuscript for
# details
tp0 = tpINIT()
tc0 = tcINIT()
PhiP0 = exp(-(integrate(mortalityP, t0 - tp0, t0)$value))
PhiC0 = exp(-(integrate(mortalityC, t0 - tc0, t0)$value))
# List of all initial Values
yinit <- c(A0, P0, tp0, I0, C0, tc0, PhiP0, PhiC0);
x = dde(y = yinit, func = lice, parms = parameters, times = seq(t0, tfin, 1), hbsize = 1000000)
return(x)
}
# The reported critical stocking density for BCB
fcrit<-125512.59
A0=1
I0=1
P0=1
C0=1
t0<-0
# Consider 3 different values of f.
f<-fcrit
x = sealice(0,10*365, A0,C0,I0,P0)
f<-fcrit+1e2
xp= sealice(0,10*365,A0,C0,I0,P0)
f<-fcrit-1e2
xn = sealice(0,10*365,A0,C0,I0,P0)
# Plot the results
par(mfrow=c(1,1), mar=c(5,5,1,1))
plot(xp$time/365, xp$y1, typ="l", col="blue", ylab = "A(t)", xlab="time (years)", lwd=3, xlim = c(0,10), ylim=c(.5,.7), cex.lab = 1.3, cex.axis=1.3)
lines(xn$time/365, xn$y1, col = "orange", xlim = c(0,10), ylim=c(.5,1),typ="l", lwd=3)
lines(x$time/365, x$y1, col = "black", xlim = c(0,10), ylim=c(.5,1), lwd=3)
lines(c(0,10), c(0.687,0.687))
# Clearing Workspace and loading packages
rm(list = ls())
require(PBSddesolve)
# Change the working directory so your code can find the dependent .Rdata
# files
#setwd('~/Desktop/Code')
load("ParamsFuncs.RData")
# this is to practice the quantitative training course by Amy.
x <- 4
y <- x + 1
x <- 6
z <- x + 1
z <- y + 5
q <- x + y
# use of mathematical functions that comes with R
m <- sqrt(x)
n <-  log(x)
# creating a vector using the concatenation/combine approach
vec1 = c("red", "blue", "green")
# to find the type and lenght of vec1
cl <-  class(vec1)
len <- length(vec1)
cl
len
# to create a sequence which is a vector from 0-20 increasing by 5
vec <- seq(0, 20, by=5)
vec
# creating a 3*3 matrix in R
M <-  matrix(
c(2, 3, 4, 5, 6, 7, 8, 9, 10),
nrow = 3,
ncol = 3
)
M
# to create a vector type called list in R
mylist <-  list(2, 5, "hello", "TRUE", 2+4i)
mylist
type <-  class(mylist)
type
len
# To create a dataframe in R
df <-  data.frame(id = letters[1:4], x = 1:4, y = 11:14)
df
n_rows <- nrow(df)
n_rows
n_col
n_col <- ncol(df)
n_col
dim(df)
tl <- tail(df)
table1 <- data.frame(weight = c("initial", "final",
"difference", "percent-change"),
"NaCl-0-percent" = c(NA, NA, NA, NA),
"NaCl-0.9-percent" = c(NA, NA, NA, NA),
"NaCl-2-percent" = c(NA, NA, NA, NA),
"NaCl-5-percent" = c(NA, NA, NA, NA))
table1
table1 <- data.frame(weight = c("initial", "final",
"difference", "percent-change"),
"NaCl-0-percent" = c(NA, NA, NA, NA),
"NaCl-0.9-percent" = c(NA, NA, NA, NA),
"NaCl-2-percent" = c(NA, NA, NA, NA),
"NaCl-5-percent" = c(NA, NA, NA, NA))
table1
table2 <- data.frame(weight = c("percent-change", "minimum-value",
"maximum-value", "difference"),
"NaCl-0-percent" = c(NA, NA, NA, NA),
"NaCl-0.9-percent" = c(NA, NA, NA, NA),
"NaCl-2-percent" = c(NA, NA, NA, NA),
"NaCl-5-percent" = c(NA, NA, NA, NA))
table2
# to import data into R
data1 <- read.csv(file = "solution-concentration-effect-on-potato.csv")
data2 = read.csv(file = "solution-concentration-effect-on-potato-averages.csv")
# To plot in R
x <- c(2, 4, 6, 8, 10)
y <- c(10, 20, 30, 40, 50)
x
y
plot(x, y)
plot(x, y, type = "l")
# to produce a data in R
quant_data = data.frame(C0_3 = c(233.7, 328.1, 354.0, 324.4, 438.2, 743.9, 324.2),
G = c(2.4, 3.5, 1.2, 5.5, 6.3, 4.5, 7.1)
)
quant_data
df = read.csv(file = "/Users/jbaafi/Desktop/R/biol-1001-data2.csv")
df
# Writing functions in R eg. a function that squares values.ie. x^2
square <- function(x){
eq <- x^2
return(eq)
}
#I can now call the function above to find the square of any number say 3
square(3)
# This is a function that find the product of two numbers ie. a*b
product <- function(a, b){
pro <- a*b
return(pro)
}
# Now I call the product function to find the product of any two numbers given
product(2, 5)
return(mean)
#Now we call the my_mean function to find the mean of any vector x
my_mean(2)
#Now we call the my_mean function to find the mean of any vector x
my_mean(2)
# A function to find the mean of a vector
my_mean <- function(x){
mean <- sum(x)/length(x)
return(mean)
}
#Now we call the my_mean function to find the mean of any vector x
my_mean(2)
my_mean(1:20)
my_mean(1:10)
area <- function(r){
form <- pi*r^2
return(form)
}
area(2)
area(7)
area(r=2)
area(r=7)
quadratic <- function(a, b, c){
x <- -b + sqrt(b^2-4*a*c)/2*a
return(x)
}
quadratic(2, 3, 1)
quadratic <- function(a, b, c){
x <- -b + sqrt(b^2-4*a*c)/2*a, x <- -b - sqrt(b^2-4*a*c)/2*a
return(x)
}
x <- -b + sqrt(b^2-4*a*c)/2*a; x <- -b - sqrt(b^2-4*a*c)/2*a
quadratic <- function(a, b, c){
x <- -b + sqrt(b^2-4*a*c)/2*a; x <- -b - sqrt(b^2-4*a*c)/2*a
return(x)
}
quadratic(4, 2, 6)
quadratic(4, 2, 6)
quadratic(2, 3, 1)
quadratic <- function(a, b, c){
x <-  c(-b + sqrt(b^2-4*a*c)/2*a, -b - sqrt(b^2-4*a*c)/2*a)
return(x)
}
quadratic(2, 3, 1)
quadratic(1, -2, 3)
quadratic(1, -2, 3)
quadratic <- function(a, b, c){
x <-  c(-b + sqrt(b^2-4*a*c)/2*a, -b - sqrt(b^2-4*a*c)/2*a)
return(x)
}
quadratic(2, 3, 1)
quadratic(1, -2, 3)
quadratic <- function(a, b, c){
x <-  c(-b + (sqrt(b^2-(4*a*c)))/2*a, -b - (sqrt(b^2-4*a*c))/2*a)
return(x)
}
quadratic(2, 3, 1)
quadratic(1, -2, 3)
quadratic(1, 2, 3)
library(PBSddesolve)
quadratic(2, 3, 2)
quadratic <- function(a, b, c){
x <-  c(-b + (sqrt(b^2-(4*a*c)))/2*a, -b - (sqrt(b^2-4*a*c))/2*a)
return(x)
}
quadratic(2, 3, 2)
quadratic(2, 3, 1)
library(PBSddesolve)
cooling_law <- function(t, y){
dy <- -rho*(y[1] - Tenv)
return(dy)
}
#Now specify parameter values and initial conditions
rho <- 0.1
Tenv <- 25
t0 <- 0
t1 <- 100
Tcup <- 65
# Now I call the dde function to solve the the system above
yout <- dde(y = Tcup, func = cooling_law, times = seq(t0, t1, length = 100), hbsize = 0)
# We plot the solution of the system, yout
plot(yout$time, yout$y1, type = "l", xlab = "Time", ylab = "Temperature",
main = "Cooling of a cup of coffee")
Lorenz <- function(t, y){
dy1 <- sigma*(y[2]-y[1])
dy2 <- y[1]*(tau-y[3])-y[2]
dy3 <- y[1]*y[2]-rho*y[3]
return(c(dy1, dy2, dy3))
}
# We specify parameter values and initial conditions
sigma <- 10
tau <- 25
rho <- 2
t <- seq(0, 20, by = 0.01)
y0 <- c(10, 0, 10)
yout2 <- dde(y=y0, func = Lorenz, times = t, hbsize = 0)
head(yout2)
plot(yout2$time, yout2$y1)
plot(yout2$time, yout2$y2)
plot(yout2$time, yout2$y3)
plot(yout2)
Blowflies <- function(t, y){
if (t-t0>=tau) {ylag <- pastvalue(t-tau)}
else {ylag <- 0}
yexp <- exp(-theta*ylag[1]/A0)
yp <- p*ylag[1]*yexp - delta*y[1]
return(list(yp, c(dy=yp, exp=yexp)))
}
# Now we specify parameters and initial history
tau <- 12
p <- 10
theta <- 0.33
delta <- 0.25
t0 <- 0
t1 <- 300
A0 <- 100
# call the dde function to solve system of DDEs
y = dde(y=A0, times=seq(t0, t1, length = 1000), func=Blowflies,
parms=NULL, switchfunc=NULL, mapfunc=NULL, tol=1e-08,
dt=0.1, hbsize=10000)
head(y)
yout4 <- data.frame(y)
head(yout4)
plot(yout4$time, yout4$y1, type = "l", xlab = "Time", ylab = "Population",
main = "Adult Blowfly Population")
plot(yout4$time, yout4$dy, type = "l")
plot(yout4$time, yout4$exp, type = "l")
# Examples from the PBSddesolve manual
#create a func to return dde gradient
yprime <- function(t,y,parms) {
if (t < parms$tau) lag <- parms$initial
else
lag <- pastvalue(t - parms$tau)
y1 <- parms$a * y[1] - (y[1]^3/3) + parms$m * (lag[1] - y[1])
y2 <- y[1] - y[2]
return(c(y1,y2))
}
# Examples from the PBSddesolve manual
#create a func to return dde gradient
yprime <- function(t,y,parms) {
if (t < parms$tau) lag <- parms$initial
else
lag <- pastvalue(t - parms$tau)
y1 <- parms$a * y[1] - (y[1]^3/3) + parms$m * (lag[1] - y[1])
y2 <- y[1] - y[2]
return(c(y1,y2))
}
#define initial values and parameters
yinit <- c(1,1)
parms <- list(tau=3, a=2, m=-10, initial=yinit)
# solve the dde system
yout <- dde(y=yinit,times=seq(0,30,0.1),func=yprime,parms=parms)
# and display the results
plot(yout$time, yout$y1, type="l", col="red", xlab="t", ylab="y",
ylim=c(min(yout$y1, yout$y2), max(yout$y1, yout$y2)))
lines(yout$time, yout$y2, col="blue")
legend("topleft", legend = c("y1", "y2"),lwd=2, lty = 1,
xjust = 1, yjust = 1, col = c("red","blue"))
#define initial values and parameters
yinit <- c(1,1)
parms <- list(tau=3, a=2, m=-10, initial=yinit)
# solve the dde system
yout <- dde(y=yinit,times=seq(0,30,0.1),func=yprime,parms=parms)
# and display the results
plot(yout$time, yout$y1, type="l", col="red", xlab="t", ylab="y",
ylim=c(min(yout$y1, yout$y2), max(yout$y1, yout$y2)))
head(yout)
# and display the results
plot(yout$time, yout$y1, type="l", col="red", xlab="t", ylab="y",
ylim=c(min(yout$y1, yout$y2), max(yout$y1, yout$y2)))
lines(yout$time, yout$y2, col="blue")
len
length(yout)
dim(yout)
nrow(yout)
rm(list = ls())
source('~/Desktop/R-codes/functions.R', echo=TRUE)
square(2)
my_mean(c(2, 3, 4, 5))
my_mean(seq(2, 5))
quadratic(1,2,4)
quadratic(2, 3, 1)
# We plot the solution of the system, yout
plot(yout$time, yout$y1, type = "l", xlab = "Time", ylab = "Temperature",
main = "Cooling of a cup of coffee")
# Now I call the dde function to solve the the system above
yout <- dde(y = Tcup, func = cooling_law, times = seq(t0, t1, length = 100), hbsize = 0)
yout
# Now I call the dde function to solve the the system above
yout <- dde(y = Tcup, func = cooling_law, times = seq(t0, t1, length = 100), hbsize = 0)
# We plot the solution of the system, yout
plot(yout$time, yout$y1, type = "l", xlab = "Time", ylab = "Temperature",
main = "Cooling of a cup of coffee")
# We plot the solution of the system, yout
plot(yout$time, yout$y1, type = "l", xlab = "Time", ylab = "Temperature",
main = "Cooling of a cup of coffee")
cooling_law <- function(t, y){
dy <- -rho*(y[1] - Tenv)
return(dy)
}
#Now specify parameter values and initial conditions
rho <- 0.1
Tenv <- 25
t0 <- 0
t1 <- 100
Tcup <- 65
# Now I call the dde function to solve the the system above
yout <- dde(y = Tcup, func = cooling_law, times = seq(t0, t1, length = 100), hbsize = 0)
# We plot the solution of the system, yout
plot(yout$time, yout$y1, type = "l", xlab = "Time", ylab = "Temperature",
main = "Cooling of a cup of coffee")
dy2 <- y[1]*(tau-y[3])-y[2]
dy3 <- y[1]*y[2]-rho*y[3]
return(c(dy1, dy2, dy3))
Lorenz <- function(t, y){
dy1 <- sigma*(y[2]-y[1])
dy2 <- y[1]*(tau-y[3])-y[2]
dy3 <- y[1]*y[2]-rho*y[3]
return(c(dy1, dy2, dy3))
}
# We specify parameter values and initial conditions
sigma <- 10
Lorenz <- function(t, y){
dy1 <- sigma*(y[2]-y[1])
dy2 <- y[1]*(tau-y[3])-y[2]
dy3 <- y[1]*y[2]-rho*y[3]
return(c(dy1, dy2, dy3))
}
# We specify parameter values and initial conditions
sigma <- 10
tau <- 25
rho <- 2
t <- seq(0, 20, by = 0.01)
y0 <- c(10, 0, 10)
yout2 <- dde(y=y0, func = Lorenz, times = t, hbsize = 0)
yout2
head(yout2)
plot(yout2$time, yout2$y1)
plot(yout2$time, yout2$y2)
plot(yout2$time, yout2$y3)
plot(yout2)
Blowflies <- function(t, y){
if (t-t0>=tau) {ylag <- pastvalue(t-tau)}
else {ylag <- 0}
yexp <- exp(-theta*ylag[1]/A0)
yp <- p*ylag[1]*yexp - delta*y[1]
return(list(yp, c(dy=yp, exp=yexp)))
}
Blowflies <- function(t, y){
if (t-t0>=tau) {ylag <- pastvalue(t-tau)}
else {ylag <- 0}
yexp <- exp(-theta*ylag[1]/A0)
yp <- p*ylag[1]*yexp - delta*y[1]
return(list(yp, c(dy=yp, exp=yexp)))
}
# Now we specify parameters and initial history
tau <- 12
p <- 10
theta <- 0.33
delta <- 0.25
t0 <- 0
t1 <- 300
A0 <- 100
# call the dde function to solve system of DDEs
y = dde(y=A0, times=seq(t0, t1, length = 1000), func=Blowflies,
parms=NULL, switchfunc=NULL, mapfunc=NULL, tol=1e-08,
dt=0.1, hbsize=10000)
head(y)
head(yout4)
plot(yout4$time, yout4$y1, type = "l", xlab = "Time", ylab = "Population",
main = "Adult Blowfly Population")
rm(list = ls())
source('~/Desktop/R-codes/edx/edx-data-analysis-R.R', echo=TRUE)
library(dslabs)
library(dslabs)
data(heights)
options(digits = 3)
head(heights)
length(heights)
nrow(heights)
class(heights)
describe(heights)
mean(heights$height)
ind <- heights$height>68.3
ind
sum(ind=TRUE)
length(ind)
class(ind)
dim(ind)
name(ind)
ncol(ind)
names(ind)
ind <- count(heights$height>68.3)
ind <- heights$height>68.3
ind
which(ind)
length(which(ind))
above_mean <- which(ind)
above_mean
?swirl
??swirl
library(swirl)
swirl()
quite
exit
swirl()
source('~/Desktop/R-codes/functions.R', echo=TRUE)
0.7*10
0.2*7
4*1.4
7+5.6
rain <- c + d*sin(pi * t/365)
source('~/Desktop/R-codes/mosquito_model_ODE.R', echo=TRUE)
hhead(x)
head(x)
head(x)
