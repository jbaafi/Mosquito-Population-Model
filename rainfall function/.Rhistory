f2 <- exp(-x)
fit.lm <- lm(y~f1)
fit <- fitted(fit.lm)
pred <- predict(fit.lm, newdata = data.frame(x=x))
#Plotting the data with fitted function with the base plot function
plot(y ~ x)
lines( x, fit, col="blue")
summary(fit.lm)
lambda <- 0.674043   #0.749641 #1/mean(x)
f <- lambda*exp(-lambda*x)
plot(x, f1, "l", col = "red")
points(x, y, col = "blue")
fit.lm <- lm(y~f)
fit <- fitted(fit.lm)
pred <- predict(fit.lm, newdata = data.frame(x=x))
#Plotting the data with fitted function with the base plot function
plot(y ~ x)
lines( x, fit, col="blue")
summary(fit.lm)
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL,start=list(lambda = 0.7), )
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start=list(lambda = 0.7))
mle.expon <- mle2(expon.negLL, start=list(lambda = 0.7))
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
-sum(dlnorm(y, mean=exponential(lambda), log=TRUE))
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), log=TRUE))
}
mle.expon <- mle2(expon.negLL, start=list(lambda = 0.7))
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start=list(lambda = 0.7))
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, fixed=list(lambda=0.6))
lambda <- unname(coef(mle.expon))
lambda
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
mle.expon <- mle2(expon.negLL, start = list(lambda=0.2))
mle.expon <- mle2(expon.negLL, start = list(lambda=1))
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
expon.negLL = function(lambda){
-sum(dlnorm(x, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
lambda <- unname(coef(mle.expon))
lambda
plot(density~precipitation, data = sub.df) # Probability
plot(y~x) # Probability
lines(x, exponential(lambda), col="blue", pch=20)
lines(fit, col="red")
lines(x, fit, col="red")
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(x, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
lambda <- unname(coef(mle.expon))
lambda
plot(y~x) # Probability
lines(x, exponential(lambda), col="blue", pch=20)
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(y, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(x, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.6))
lambda <- unname(coef(mle.expon))
lambda
plot(y~x) # Probability
lines(x, exponential(lambda), col="blue", pch=20)
lines(x, fit, col="red")
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(x, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.67))
lambda <- unname(coef(mle.expon))
lambda
plot(y~x) # Probability
lines(x, exponential(lambda), col="blue", pch=20)
lines(x, fit, col="red")
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
# Fitting a log-normal distribution
mu <- 0.674043
delta <- 0.5
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
mean(x)
# Fitting a log-normal distribution
mu <- 23
delta <- 0.5
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
0.674043
0.674043
0.674043
# Fitting a log-normal distribution
mu <- 0.674043
delta <- 0.5
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.674043
delta <- 0.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
# Fitting a log-normal distribution
mu <- 0.574043
delta <- 0.5
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 0.5
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 0.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 0.8
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 0.97
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 1.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, logn, "l", col = "red")
points(x, y, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 1.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 1.0
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
# Fitting a log-normal distribution
mu <- 0.474043
delta <- 1.1
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
# Fitting a log-normal distribution
mu <- 0.4994043
delta <- 1.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
fit.logn <- lm(y~logn)
fit <- fitted(fit.logn)
pred <- predict(fit.logn, newdata = data.frame(x=x))
#Plotting the data with fitted function with the base plot function
plot(y ~ x)
lines( x, fit.logn, col="blue")
summary(fit.lm)
lines( x, fit.logn, col="blue")
fit.logn <- lm(y~logn)
fit <- fitted(fit.logn)
pred <- predict(fit.logn, newdata = data.frame(x=x))
#Plotting the data with fitted function with the base plot function
plot(y ~ x)
lines( x, fit.logn, col="blue")
lines(x, pred)
summary(fit.lm)
# Fitting a log-normal distribution
mu <-  0.004358 #0.4994043
delta <- 0.803337 #1.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
m <- nls(y ~ logn, data = df2, start = list(mu = 0.499, delta = 1.2))
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="red",lty=2,lwd=3)
summary(m)
coef(m)
# Fitting a log-normal distribution
mu <-  0.2951328 #0.4994043
delta <- 1.8758427 #1.2
logn <- (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2))
plot(x, y, col = "red")
lines(x, logn, col = "blue")
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="red",lty=2,lwd=3)
lines(x,predict(m),col="red",lty=0,lwd=3)
plot(x, y)
lines(x,predict(m),col="red",lty=0,lwd=3)
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="red",lty=0,lwd=3)
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="red", lwd=3)
plot(x, y)
lines(x,predict(m),col="red")
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
#################################################################################
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="blue")
summary(exp)
coef(exp)
######################################################################################
# I just fit the log-normal PDF to data by the nls() function.
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="blue")
#################################################################################
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
######################################################################################
# I just fit the log-normal PDF to data by the nls() function.
m <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(m),col="red")
summary(m)
coef(m)
################################################################################
# Estimating the lambda parameter with the MLE
exponential <- function(lambda){
d <- lambda*exp(-lambda*x)
}
expon.negLL = function(lambda){
-sum(dlnorm(x, mean=exponential(lambda), sd=1, log=TRUE))
}
mle.expon <- mle2(expon.negLL, start = list(lambda=0.67))
lambda <- unname(coef(mle.expon))
lambda
plot(y~x) # Probability
lines(x, exponential(lambda), col="blue", pch=20)
lines(x, fit, col="red")
#################################################################################
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
# clear workspace
rm(list=ls())
# set working directory
setwd("/Users/jbaafi/Google Drive/My Drive/rainfall function")
# importing packages needed
packages <- c("tidyverse", "stringr", "dplyr", "base",
"ggplot2", "patchwork", "bbmle", "fitdistrplus")
lapply(packages, require, character.only = TRUE)
# reading dataset into r
precip <- read.csv("/Users/jbaafi/Google Drive/My Drive/rainfall function/climate.df.csv")
attach(precip)
# minimum precipitation recorded
min(precip$Total.Precip)
# maximum precipitation recorded
max(precip$Total.Precip)
# drawing a histogram!
hist(precip$Total.Precip, breaks = 50)
#counting the number of zero recordings in the total.precip data
precip[(precip$Total.Precip==0),]
sum(precip$Total.Precip==0)
# eliminating zero recordings
df <- precip %>%
filter(Total.Precip != 0 & !is.na(Total.Precip) & Total.Precip <= 50) %>%
arrange(Total.Precip)
#ploting the histogram without zero recordings
hist_precip <-  hist(df$Total.Precip, breaks = 100, plot = T)
plot(hist_precip$mids, hist_precip$counts, "l")
plot(hist_precip$mids, hist_precip$density, type = "l")
df2 <- data.frame(hist_precip$mids, hist_precip$counts, hist_precip$density)
df2 <- df2 %>%
rename(precip = hist_precip.mids, freq = hist_precip.counts, density = hist_precip.density)
################################################################################
x <- df2$precip
y <- df2$density
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
# I just fit the log-normal PDF to data by the nls() function.
logn <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
# fitting the log-normal PDF to data by the nls() function.
logn <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(logn),col="red")
summary(logn)
coef(logn)
rm(list=ls())
# Setting working directory
setwd("/Users/jbaafi/Desktop/jake")
#load("ParamsFuncs.RData")
#load("farmNL.RData")
# Needed packages ---------------------------------------------------------------
# install.packages(c("tidyverse", "stringr", "dplyr")) # If packages need to be installed
x <-c("tidyverse", "stringr", "dplyr", "base",
"ggplot2", "patchwork", "bbmle")
lapply(x, require, character.only = TRUE)
# Loading Bay D'Esspoir dataset
baydespoir_prof <- read.csv("/Users/jbaafi/Desktop/jake/baydespoir_prof.csv")
hist(baydespoir_prof$PSAL)
# Setting data frame that will be used in the loop.
simulation.data.frame=NULL
# Loop parameters ---------------------------------------------------------------
# k=10 # Salinity variance for j loop
N=1 # Number of simulation that the loop will rerun for each variance for v loop
TT= 2*365 # Number of days the model will run
# Time
dtime = 1
time <-  seq(0, TT, dtime)
time0 <-time[1]
# Temperature Functions
Temp = function(t){
Temp = a + b1*sin(2 * pi * t/365) + b2*cos(2 * pi * t/365)
return(Temp)
}
Temp1 = function(t){
Temp = 6.4294 + 3.32*sin(2 * pi * t/365) + 4.61*cos(2 * pi * t/365)
return(Temp)
}
Temp1(time.seq)
time.seq <- seq(0, 365, 0.5)
Temp(time)
# time.temp <- as.data.frame(cbind(t, Temp(t)))
# ggplot(time.temp, aes(x=t, y=Temp(t))) +
#   geom_line()+
#   geom_point() +
#   theme_classic() +
dx <- 0.5 # you may change this.
sub.edge <- seq(15, 40, dx) # min max rainfall mm you wanna consider
sub.mid <- seq(15+dx/2, 40-dx/2, dx) #same (???Not very sure what this means! I think is the class midpoint for the hist)
sub.x <- sub.mid #same
# Subsetting to only take values that are greater than 15
# J.B At this point we subset the actual data to set the x-axis similar to that
# of the distribution done just above this.
sub.bay <- subset(baydespoir_prof, PSAL >= 15) # shound conform to the minimum from line 77
sub.bay <- na.omit(sub.bay$PSAL)
# Plotting the subset distribution. The histogram also comes with the counts and densities
sub.hist <- hist(sub.bay, sub.edge) # Plotting the histogram when subsetted from 15-40.
sub.freq <- sub.hist$counts # This gives the counts of each interval (ie. frequencies)
sub.freq <- sub.freq/sum(sub.freq) # This gives the densities
sum(sub.freq) # Should sum to 1, ie. the probability density should sum up to 1.
# Checking to make sure that they're the same length
length(sub.freq)
length(sub.x)
# Find the m value (m is a parameter in the asymmetric Laplace distribution)
sub.df <- as.data.frame(cbind(sub.x, sub.hist$counts))
sub.df[which.max(sub.df$V2),]  # The maxium value for m therefore is 32.2
sub.m <- sub.df[which.max(sub.df$V2),][1,1] # Pulls only the m value
sigma=1
# Need to update the asymmetric laplace distribution so that it pulls the right
# x value
sub.asy.laplace <- function(sub.m, pho, k){
d <- dx*(pho/(k+(1/k)))*exp(-((sub.x-sub.m)*pho*(sign(sub.x-sub.m))*k^(sign(sub.x-sub.m))))
} # Same distrubution but x was changed to sub.x. Sub.x is the x-vector for the subset data
sub.negLL = function(pho, k){
-sum(dnorm(sub.freq, mean=sub.asy.laplace(sub.m, pho, k), sd=sigma, log=TRUE))
} # Only want to fit to pho and k so only include them within the code
sub.mle.asy.laplace.Ex <- mle2(sub.negLL,
start=list(pho=1, k=3), ) # Similary, only want to fit to pho and k
a.est <- unname(coef(sub.mle.asy.laplace.Ex))[-4]
# fitted asymmetric distrubution
print(a.est)
# Initial fitted values
pho0 <- a.est[1]
k0 <- a.est[2]
# # The probability distribution is described by
plot(sub.x, sub.asy.laplace(sub.m, a.est[1], a.est[2]), type="l", ylim=c(0,1.1)) # Probability
#lines(sub.x, cumsum(sub.asy.laplace(sub.m, a.est[1], a.est[2])), col="red") # Cumlative
points(sub.x, sub.freq, col="blue", pch=20)
# Combining the distributions into one distribution
sub.sal.df <- as.data.frame(cbind(sub.x, sub.asy.laplace(sub.m, a.est[1], a.est[2]),
cumsum(sub.asy.laplace(sub.m, a.est[1], a.est[2]))))
names(sub.sal.df) <- c("Salinity Values", "PDF", "CDF")
head(sub.sal.df)
# Created on: Sept 15, 2021
# By:         jbaafi
# clear workspace
rm(list=ls())
# set working directory
setwd("/Users/jbaafi/Google Drive/My Drive/rainfall function")
# importing packages needed
packages <- c("tidyverse", "stringr", "dplyr", "base",
"ggplot2", "patchwork", "bbmle", "fitdistrplus")
lapply(packages, require, character.only = TRUE)
# reading dataset into r
precip <- read.csv("/Users/jbaafi/Google Drive/My Drive/rainfall function/climate.df.csv")
attach(precip)
# minimum precipitation recorded
min(precip$Total.Precip)
# maximum precipitation recorded
max(precip$Total.Precip)
# drawing a histogram!
hist(precip$Total.Precip, breaks = 50)
#counting the number of zero recordings in the total.precip data
precip[(precip$Total.Precip==0),]
sum(precip$Total.Precip==0)
# eliminating zero recordings
df <- precip %>%
filter(Total.Precip != 0 & !is.na(Total.Precip) & Total.Precip <= 50) %>%
arrange(Total.Precip)
#ploting the histogram without zero recordings
hist_precip <-  hist(df$Total.Precip, breaks = 100, plot = T)
plot(hist_precip$mids, hist_precip$counts, "l")
plot(hist_precip$mids, hist_precip$density, type = "l")
df2 <- data.frame(hist_precip$mids, hist_precip$counts, hist_precip$density)
df2 <- df2 %>%
rename(precip = hist_precip.mids, freq = hist_precip.counts, density = hist_precip.density)
################################################################################
x <- df2$precip
y <- df2$density
# Using the nls() function to fit exponential function to data
exp<- nls(y ~ lambda*exp(-lambda*x), data = df2, start = list(lambda = 0.67))
plot(x, y)
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
# fitting the log-normal PDF to data by the nls() function.
logn <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y)
lines(x,predict(logn),col="red")
summary(logn)
coef(logn)
plot(x, y, col = "blue", ylim = c(0, 1))
lines(x,predict(logn),col="red")
plot(x, y, col = "blue", ylim = c(0, 0.7))
lines(x,predict(logn),col="red")
plot(x, y, col = "blue", ylim = c(0, 0.7))
lines(x,predict(exp),col="red")
summary(exp)
coef(exp)
# fitting the log-normal PDF to data by the nls() function.
logn <- nls(y ~ (1/(x*delta*sqrt(2*pi)))*exp(-((log(x)-mu)^2)/(2*delta^2)), data = df2, start = list(mu = 0.499, delta = 1.2))
plot(x, y, col = "blue", ylim = c(0, 0.7))
lines(x,predict(logn),col="red")
summary(logn)
